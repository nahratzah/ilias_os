#ifndef _MEMORY_
#define _MEMORY_

#include <memory-fwd.h>
#include <cdecl.h>
#include <cstddef>
#include <atomic>
#include <iosfwd>
#include <iterator>
#include <limits>
#include <new>
#include <tuple>
#include <utility>
#include <stdimpl/alloc_traits.h>
#include <stdimpl/pointer_traits.h>
#include <stdimpl/unique_ptr_support.h>
#include <stdimpl/functional_comparators.h>

_namespace_begin(std)


template<typename T> T* addressof(T&) noexcept;


template<typename T>
class __attribute__((deprecated("auto_ptr is deprecated in C++11, "
                                "please use unique_ptr instead.")))
    auto_ptr_ref;
template<typename T>
class __attribute__((deprecated("auto_ptr is deprecated in C++11, "
                                "please use unique_ptr instead.")))
    auto_ptr;


template<typename Ptr> struct pointer_traits {
 public:
  using pointer = Ptr;
  using element_type = impl::pointer::select_element_type<Ptr>;
  using difference_type = typename conditional_t<
      impl::pointer::member_type_check_difference_type<Ptr>::value,
      Ptr,
      impl::pointer::difference_type_default<ptrdiff_t>>::difference_type;

  template<typename T> using rebind =
      typename impl::pointer::resolve_rebind<T, Ptr>;

 private:
  using pointer_to_arg = conditional_t<is_void<element_type>::value,
                                       impl::pointer::cannot_instantiate_me,
                                       element_type>;

 public:
  pointer pointer_to(pointer_to_arg& r) { return pointer::pointer_to(r); }
};

template<typename T> struct pointer_traits<T*> {
 public:
  using pointer = T*;
  using element_type = T;
  using difference_type = ptrdiff_t;
  template<typename U> using rebind = U*;

 private:
  using pointer_to_arg = conditional_t<is_void<element_type>::value,
                                       impl::pointer::cannot_instantiate_me,
                                       element_type>;

 public:
  pointer pointer_to(pointer_to_arg& r) { return addressof(r); }
};


enum class pointer_safety { relaxed, preferred, strict };

void declare_reachable(void*);
template<typename T> T* undeclare_reachable(T*);
void declare_no_pointers(char*, size_t);
void undeclare_no_pointers(char*, size_t);
pointer_safety get_pointer_safety() noexcept;


void* align(size_t, size_t, void*&, size_t&);


constexpr allocator_arg_t allocator_arg = allocator_arg_t();


template<typename Alloc> struct allocator_traits {
  using value_type = typename Alloc::value_type;
  using pointer = typename impl::allocator::traits_select<
      impl::allocator::member_type_check_pointer<Alloc>,
      Alloc>::pointer;
  using const_pointer = typename impl::allocator::traits_select<
      impl::allocator::member_type_check_const_pointer<Alloc>,
      Alloc>::const_pointer;

  using difference_type = typename conditional_t<
      impl::allocator::member_type_check_difference_type<Alloc>::value,
      Alloc,
      pointer_traits<pointer>>::difference_type;
  using size_type = typename conditional_t<
      impl::allocator::member_type_check_size_type<Alloc>::value,
      Alloc,
      impl::allocator::size_type_for_difference_type<difference_type>
      >::size_type;

  using void_pointer = typename conditional_t<
      impl::allocator::member_type_check_void_pointer<Alloc>::value,
      Alloc,
      impl::allocator::void_pointer_for_pointer<pointer, const_pointer>
      >::void_pointer;
  using const_void_pointer = typename conditional_t<
      impl::allocator::member_type_check_const_void_pointer<Alloc>::value,
      Alloc,
      impl::allocator::void_pointer_for_pointer<pointer, const_pointer>
      >::const_void_pointer;

  using propagate_on_container_copy_assignment = typename conditional_t<
      impl::allocator::member_type_check_propagate_on_container_copy_assignment<Alloc>::value,
      Alloc,
      impl::allocator::alloc_traits_propagate_defaults
      >::propagate_on_container_copy_assignment;
  using propagate_on_container_move_assignment = typename conditional_t<
      impl::allocator::member_type_check_propagate_on_container_move_assignment<Alloc>::value,
      Alloc,
      impl::allocator::alloc_traits_propagate_defaults
      >::propagate_on_container_move_assignment;
  using propagate_on_container_swap = typename conditional_t<
      impl::allocator::member_type_check_propagate_on_container_swap<Alloc>::value,
      Alloc,
      impl::allocator::alloc_traits_propagate_defaults
      >::propagate_on_container_swap;

  template<typename T, typename... Args>
  static void construct(Alloc& alloc, T* p, Args&&... args)
      noexcept(noexcept(impl::allocator::construct(alloc, p,
                                                  forward<Args>(args)...))) {
    impl::allocator::construct(alloc, p, forward<Args>(args)...);
  }

  template<typename T>
  static void destroy(Alloc& alloc, T* p)
      noexcept(noexcept(impl::allocator::destroy(alloc, p))) {
    impl::allocator::destroy(alloc, p);
  }

  static pointer allocate(Alloc& alloc, size_type n)
      noexcept(noexcept(alloc.allocate(n))) {
    return alloc.allocate(n);
  }

  static pointer allocate(Alloc& alloc, size_type n, const_void_pointer hint)
      noexcept(noexcept(impl::allocator::allocate<pointer>(alloc, move(n),
                                                          move(hint)))) {
    return impl::allocator::allocate<pointer>(alloc, move(n), move(hint));
  }

  static void deallocate(Alloc& alloc, pointer p, size_type n) noexcept {
    alloc.deallocate(p, n);
  }

  static size_type max_size(const Alloc& alloc) noexcept {
    return impl::allocator::max_size<size_type>(alloc);
  }

  static Alloc select_on_container_copy_construction(const Alloc& alloc)
      noexcept(noexcept(
        impl::allocator::select_on_container_copy_construction(alloc))) {
    return impl::allocator::select_on_container_copy_construction(alloc);
  }

  template<typename T> using rebind_alloc =
      impl::allocator::resolve_rebind<T, Alloc>;
  template<typename T> using rebind_traits = allocator_traits<rebind_alloc<T>>;
};


template<typename T> class allocator;

template<> class allocator<void> {
 public:
  using value_type = void;
  using pointer = void*;
  using const_pointer = const void*;
  using propagate_on_container_move_assignment = true_type;
  template<typename U> struct rebind { typedef allocator<U> other; };

  allocator() = default;
  allocator(const allocator&) = default;
  template<typename U> allocator(const allocator<U>&) noexcept;
};

template<typename T> class allocator {
 public:
  using value_type = T;
  using pointer = T*;
  using const_pointer = const T*;
  using reference = T&;
  using const_reference = const T&;
  using size_type = size_t;
  using difference_type = ptrdiff_t;
  using propagate_on_container_move_assignment = true_type;
  template<typename U> struct rebind { typedef allocator<U> other; };

  allocator() = default;
  allocator(const allocator&) = default;
  template<typename U> allocator(const allocator<U>&) noexcept;

  pointer address(reference x) const noexcept;
  const_pointer address(const_reference x) const noexcept;
  pointer allocate(size_type, allocator<void>::const_pointer = nullptr);
  void deallocate(pointer, size_type);
  size_type max_size() const noexcept;

  template<typename U, typename... Args> void construct(U* p, Args&&... args)
      noexcept(noexcept(::new (static_cast<void*>(p))
                              U(forward<Args>(args)...)));

  template<typename U> void destroy(U* p)
      noexcept(noexcept(p->~U()));
};

template<typename T, typename U>
bool operator==(const allocator<T>&, const allocator<U>&) noexcept;
template<typename T, typename U>
bool operator!=(const allocator<T>&, const allocator<U>&) noexcept;


template<typename OutputIterator, typename T>
class raw_storage_iterator
: public iterator<output_iterator_tag, void, void, void, void>
{
 public:
  explicit raw_storage_iterator(OutputIterator);

  raw_storage_iterator& operator*();
  raw_storage_iterator& operator=(const T&);
  raw_storage_iterator& operator++();
  raw_storage_iterator operator++(int);

 private:
  OutputIterator iter_;
};


template<typename T>
pair<T*, ptrdiff_t> get_temporary_buffer(ptrdiff_t) noexcept;
template<typename T>
void return_temporary_buffer(T*);


template<typename InputIterator, typename ForwardIterator>
ForwardIterator uninitialized_copy(InputIterator, InputIterator,
                                   ForwardIterator);

template<typename InputIterator, typename Size, typename ForwardIterator>
ForwardIterator uninitialized_copy_n(InputIterator, Size, ForwardIterator);

template<typename ForwardIterator, typename T>
void uninitialized_fill(ForwardIterator, ForwardIterator, const T&);

template<typename ForwardIterator, typename Size, typename T>
void uninitialized_fill_n(ForwardIterator, Size, const T&);


template<typename T> struct default_delete {
 public:
  constexpr default_delete() noexcept = default;
  template<typename U> default_delete(const default_delete<U>&) noexcept {};
  void operator()(T*) const;
};

template<typename T> struct default_delete<T[]> {
 public:
  constexpr default_delete() noexcept = default;
  void operator()(T*) const;
  template<typename U> void operator()(U*) const = delete;
};

template<typename T, typename D = default_delete<T>> class unique_ptr {
 private:
  static constexpr bool D_is_reference = is_reference<D>::value;
  static_assert(D_is_reference || is_destructible<D>::value,
                "Deleter must be destructible.");
  static_assert(!is_rvalue_reference<D>::value,
                "Cannot hold an rvalue deleter.");

 public:
  using pointer = typename impl::unique_ptr_support::pointer_type<T, D>;
  using element_type = T;
  using deleter_type = D;

 private:
  using data_type =
      tuple<pointer,
            conditional_t<D_is_reference,
                          reference_wrapper<remove_reference_t<deleter_type>>,
                          deleter_type>>;
  using deleter_copy_arg = conditional_t<
      D_is_reference,
      add_lvalue_reference_t<remove_reference_t<deleter_type>>,
      add_lvalue_reference_t<add_const_t<deleter_type>>>;
  using deleter_move_arg = conditional_t<
      D_is_reference,
      add_rvalue_reference_t<remove_reference_t<deleter_type>>,
      add_rvalue_reference_t<remove_const_t<deleter_type>>>;

 public:
  constexpr unique_ptr() noexcept;
  explicit unique_ptr(pointer) noexcept;
  unique_ptr(pointer, deleter_copy_arg d1) noexcept;
  unique_ptr(pointer, deleter_move_arg d2) noexcept;
  unique_ptr(unique_ptr&&) noexcept;
  constexpr unique_ptr(nullptr_t) noexcept : unique_ptr() {}
  template<typename U, typename E> unique_ptr(unique_ptr<U, E>&&) noexcept;
  template<typename U> unique_ptr(auto_ptr<U>&&) noexcept;
  ~unique_ptr() noexcept;

  unique_ptr& operator=(unique_ptr&&) noexcept;
  template<typename U, typename E> unique_ptr& operator=(unique_ptr<U, E>&&)
      noexcept;
  unique_ptr& operator=(nullptr_t) noexcept;

  add_lvalue_reference_t<T> operator*() const;
  pointer operator->() const noexcept;
  pointer get() const noexcept;
  deleter_type& get_deleter() noexcept;
  const deleter_type& get_deleter() const noexcept;
  explicit operator bool() const noexcept;

  pointer release() noexcept;
  void reset(pointer = pointer()) noexcept;
  void swap(unique_ptr&) noexcept;

  unique_ptr(const unique_ptr&) = delete;
  unique_ptr& operator=(const unique_ptr&) = delete;

 private:
  data_type data_;
};

template<typename T, typename D> class unique_ptr<T[], D> {
 private:
  static constexpr bool D_is_reference = is_reference<D>::value;
  static_assert(D_is_reference || is_destructible<D>::value,
                "Deleter must be destructible.");
  static_assert(!is_rvalue_reference<D>::value,
                "Cannot hold an rvalue deleter.");

 public:
  using pointer = typename impl::unique_ptr_support::pointer_type<T, D>;
  using element_type = T;
  using deleter_type = D;

 private:
  using data_type =
      tuple<pointer,
            conditional_t<D_is_reference,
                          reference_wrapper<remove_reference_t<deleter_type>>,
                          deleter_type>>;
  using deleter_copy_arg = conditional_t<
      D_is_reference,
      add_lvalue_reference_t<remove_reference_t<deleter_type>>,
      add_lvalue_reference_t<add_const_t<deleter_type>>>;
  using deleter_move_arg = conditional_t<
      D_is_reference,
      add_rvalue_reference_t<remove_reference_t<deleter_type>>,
      add_rvalue_reference_t<remove_const_t<deleter_type>>>;

 public:
  constexpr unique_ptr() noexcept;
  explicit unique_ptr(pointer) noexcept;
  unique_ptr(pointer, deleter_copy_arg) noexcept;
  unique_ptr(pointer, deleter_move_arg) noexcept;
  unique_ptr(unique_ptr&&) noexcept;
  constexpr unique_ptr(nullptr_t) noexcept : unique_ptr() {}
  ~unique_ptr() noexcept;

  /* Prevent assignment of pointers to derived types. */
  template<typename U> explicit unique_ptr(U) = delete;
  template<typename U> unique_ptr(U, deleter_copy_arg) = delete;
  template<typename U> unique_ptr(U, deleter_move_arg) = delete;

  unique_ptr& operator=(unique_ptr&&) noexcept;
  unique_ptr& operator=(nullptr_t) noexcept;

  T& operator[](size_t) const;
  pointer get() const noexcept;
  deleter_type& get_deleter() noexcept;
  const deleter_type& get_deleter() const noexcept;
  explicit operator bool() const noexcept;

  pointer release() noexcept;
  void reset(pointer = pointer()) noexcept;
  template<typename U> void reset(U) = delete;
  void swap(unique_ptr&) noexcept;

  unique_ptr(const unique_ptr&) = delete;
  unique_ptr& operator=(const unique_ptr&) = delete;

 private:
  data_type data_;
};

template<typename T, typename... Args> auto make_unique(Args&&... args) ->
    enable_if_t<!is_array<T>::value, unique_ptr<T>>;
template<typename T> auto make_unique(size_t) ->
    enable_if_t<is_array<T>::value && extent<T>::value == 0, unique_ptr<T>>;
template<typename T, typename... Args> auto make_unique(Args&&...) ->
    enable_if_t<(is_array<T>::value && extent<T>::value > 0), void> = delete;

template<typename T, typename D>
void swap(unique_ptr<T, D>&, unique_ptr<T, D>&) noexcept;

template<typename T1, typename D1, typename T2, typename D2>
bool operator==(const unique_ptr<T1, D1>&, const unique_ptr<T2, D2>&);

template<typename T1, typename D1, typename T2, typename D2>
bool operator!=(const unique_ptr<T1, D1>&, const unique_ptr<T2, D2>&);

template<typename T1, typename D1, typename T2, typename D2>
bool operator<(const unique_ptr<T1, D1>&, const unique_ptr<T2, D2>&);

template<typename T1, typename D1, typename T2, typename D2>
bool operator<=(const unique_ptr<T1, D1>&, const unique_ptr<T2, D2>&);

template<typename T1, typename D1, typename T2, typename D2>
bool operator>(const unique_ptr<T1, D1>&, const unique_ptr<T2, D2>&);

template<typename T1, typename D1, typename T2, typename D2>
bool operator>=(const unique_ptr<T1, D1>&, const unique_ptr<T2, D2>&);

template<typename T, typename D>
bool operator==(const unique_ptr<T, D>&, nullptr_t) noexcept;
template<typename T, typename D>
bool operator==(nullptr_t, const unique_ptr<T, D>&) noexcept;

template<typename T, typename D>
bool operator!=(const unique_ptr<T, D>&, nullptr_t) noexcept;
template<typename T, typename D>
bool operator!=(nullptr_t, const unique_ptr<T, D>&) noexcept;

template<typename T, typename D>
bool operator<(const unique_ptr<T, D>&, nullptr_t) noexcept;
template<typename T, typename D>
bool operator<(nullptr_t, const unique_ptr<T, D>&) noexcept;

template<typename T, typename D>
bool operator<=(const unique_ptr<T, D>&, nullptr_t) noexcept;
template<typename T, typename D>
bool operator<=(nullptr_t, const unique_ptr<T, D>&) noexcept;

template<typename T, typename D>
bool operator>(const unique_ptr<T, D>&, nullptr_t) noexcept;
template<typename T, typename D>
bool operator>(nullptr_t, const unique_ptr<T, D>&) noexcept;

template<typename T, typename D>
bool operator>=(const unique_ptr<T, D>&, nullptr_t) noexcept;
template<typename T, typename D>
bool operator>=(nullptr_t, const unique_ptr<T, D>&) noexcept;


template<typename T>
class __attribute__((deprecated("auto_ptr is deprecated in C++11, "
                                "please use unique_ptr instead.")))
    auto_ptr_ref {
 public:
  constexpr auto_ptr_ref() = default;
  auto_ptr_ref(const auto_ptr_ref&) = default;
  auto_ptr_ref& operator=(const auto_ptr_ref&) = default;

  template<typename U>
  explicit auto_ptr_ref(auto_ptr<U>& p) noexcept;

  T* release() const noexcept;

 private:
  using functor = T*(void*);

  template<typename U> static T* release_impl_(void*) noexcept;

  void* ptr_ = nullptr;
  functor* fn_ = nullptr;
};

template<typename T>
class __attribute__((deprecated("auto_ptr is deprecated in C++11, "
                                "please use unique_ptr instead.")))
    auto_ptr {
 public:
  using element_type = T;

  explicit auto_ptr(T* = nullptr) noexcept;
  auto_ptr(auto_ptr&) noexcept;
  template<typename U> auto_ptr(auto_ptr<U>&) noexcept;
  auto_ptr& operator=(auto_ptr&) noexcept;
  template<typename U> auto_ptr& operator=(auto_ptr<U>&) noexcept;
  auto_ptr& operator=(auto_ptr_ref<T>) noexcept;
  ~auto_ptr() noexcept;

  T& operator*() const noexcept;
  T* operator->() const noexcept;
  T* get() const noexcept;
  T* release() noexcept;
  void reset(T* = nullptr) noexcept;

  auto_ptr(auto_ptr_ref<T>) noexcept;
  template<typename U> operator auto_ptr_ref<U>() noexcept;
  template<typename U> operator auto_ptr<U>() noexcept;

 private:
  element_type* ptr_;
};


class bad_weak_ptr;

template<typename T> class shared_ptr;

template<typename T, typename... Args>
shared_ptr<T> make_shared(Args&&...);

template<typename T, typename A, typename... Args>
shared_ptr<T> allocate_shared(const A&, Args&&...);

template<typename T, typename U>
bool operator==(const shared_ptr<T>&, const shared_ptr<U>&) noexcept;

template<typename T, typename U>
bool operator!=(const shared_ptr<T>&, const shared_ptr<U>&) noexcept;

template<typename T, typename U>
bool operator<(const shared_ptr<T>&, const shared_ptr<U>&) noexcept;

template<typename T, typename U>
bool operator<=(const shared_ptr<T>&, const shared_ptr<U>&) noexcept;

template<typename T, typename U>
bool operator>(const shared_ptr<T>&, const shared_ptr<U>&) noexcept;

template<typename T, typename U>
bool operator>=(const shared_ptr<T>&, const shared_ptr<U>&) noexcept;

template<typename T>
bool operator==(const shared_ptr<T>&, nullptr_t) noexcept;
template<typename T>
bool operator==(nullptr_t, const shared_ptr<T>&) noexcept;

template<typename T>
bool operator!=(const shared_ptr<T>&, nullptr_t) noexcept;
template<typename T>
bool operator!=(nullptr_t, const shared_ptr<T>&) noexcept;

template<typename T>
bool operator<(const shared_ptr<T>&, nullptr_t) noexcept;
template<typename T>
bool operator<(nullptr_t, const shared_ptr<T>&) noexcept;

template<typename T>
bool operator<=(const shared_ptr<T>&, nullptr_t) noexcept;
template<typename T>
bool operator<=(nullptr_t, const shared_ptr<T>&) noexcept;

template<typename T>
bool operator>(const shared_ptr<T>&, nullptr_t) noexcept;
template<typename T>
bool operator>(nullptr_t, const shared_ptr<T>&) noexcept;

template<typename T>
bool operator>=(const shared_ptr<T>&, nullptr_t) noexcept;
template<typename T>
bool operator>=(nullptr_t, const shared_ptr<T>&) noexcept;

template<typename T> void swap(shared_ptr<T>&, shared_ptr<T>&) noexcept;


template<typename T, typename U>
shared_ptr<T> static_pointer_cast(const shared_ptr<U>&) noexcept;
template<typename T, typename U>
shared_ptr<T> dynamic_pointer_cast(const shared_ptr<U>&) noexcept;
template<typename T, typename U>
shared_ptr<T> const_pointer_cast(const shared_ptr<U>&) noexcept;

template<typename D, typename T> D* get_deleter(const shared_ptr<T>&) noexcept;

template<typename E, typename T, typename Y>
basic_ostream<E, T>& operator<<(basic_ostream<E, T>&, const shared_ptr<Y>&);


template<typename T> class weak_ptr;

template<typename T> void swap(weak_ptr<T>&, weak_ptr<T>&) noexcept;

template<typename T> class owner_less;

template<typename T> class enable_shared_from_this;


template<typename T>
bool atomic_is_lock_free(const shared_ptr<T>*);

template<typename T>
shared_ptr<T> atomic_load(const shared_ptr<T>*);
template<typename T>
shared_ptr<T> atomic_load_explicit(const shared_ptr<T>*, memory_order);
template<typename T>
shared_ptr<T> atomic_store(const shared_ptr<T>*, shared_ptr<T>);
template<typename T>
shared_ptr<T> atomic_store_explicit(const shared_ptr<T>*, shared_ptr<T>,
                                    memory_order);
template<typename T>
shared_ptr<T> atomic_exchange(shared_ptr<T>*, shared_ptr<T>);
template<typename T>
shared_ptr<T> atomic_exchange_explicit(shared_ptr<T>*, shared_ptr<T>,
                                       memory_order);
template<typename T>
bool atomic_compare_exchange_weak(shared_ptr<T>*, shared_ptr<T>*,
                                  shared_ptr<T>);
template<typename T>
bool atomic_compare_exchange_strong(shared_ptr<T>*, shared_ptr<T>*,
                                    shared_ptr<T>);
template<typename T>
bool atomic_compare_exchange_weak_explicit(shared_ptr<T>*, shared_ptr<T>*,
                                           shared_ptr<T>,
                                           memory_order, memory_order);
template<typename T>
bool atomic_compare_exchange_strong_explicit(shared_ptr<T>*, shared_ptr<T>*,
                                             shared_ptr<T>,
                                             memory_order, memory_order);


template<typename T> struct hash;
template<typename T, typename D> struct hash<unique_ptr<T, D>>;
template<typename T> struct hash<shared_ptr<T>>;


_namespace_end(std)

#include <memory-inl.h>

#endif /* _MEMORY_ */
