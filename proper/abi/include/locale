#ifndef _LOCALE_
#define _LOCALE_

#include <cdecl.h>
#include <iosfwd>
#include <type_traits>
#include <string>
#include <locale_misc/lc_mask.h>
#include <locale_misc/locale_t.h>

#ifdef _COMPILING_LOCALE
# include <locale.h>
#endif

_namespace_begin(std)


class locale;

template<typename Facet> const Facet& use_facet(const locale&);
template<typename Facet> bool has_facet(const locale&) noexcept;


class locale {
  template<typename Facet> friend const Facet& use_facet(const locale&);
  template<typename Facet> friend bool has_facet(const locale&) noexcept;
#ifdef _COMPILING_LOCALE
  friend locale_t newlocale(int, const char*, locale_t) noexcept;
  friend locale_t uselocale(locale_t) noexcept;
  friend char* setlocale(int, const char*) noexcept;
#endif

 public:
  class facet;
  class id;
  using category = int;
#ifdef _COMPILING_LOCALE
  class facet_ptr;
#endif

  static constexpr category none     = 0,
                            collate  = LC_COLLATE_MASK,
                            ctype    = LC_CTYPE_MASK,
                            monetary = LC_MONETARY_MASK,
                            numeric  = LC_NUMERIC_MASK,
                            time     = LC_TIME_MASK,
                            messages = LC_MESSAGES_MASK,
                            all      = LC_ALL_MASK;

  locale() noexcept;
  locale(const locale&) noexcept;
  locale(locale&&) noexcept;
  explicit locale(const char*);
  explicit locale(const string&);
  explicit locale(string_ref);
  locale(const locale&, const char*, category);
  locale(const locale&, const string&, category);
  locale(const locale&, string_ref, category);
  template<typename Facet> locale(const locale&, Facet*);
  locale(const locale&, const locale&, category);
  ~locale() noexcept;

  const locale& operator=(const locale&) noexcept;
  const locale& operator=(locale&&) noexcept;
  template<typename Facet> locale combine(const locale&) const;

  string name() const;

  bool operator==(const locale&) const;
  bool operator!=(const locale&) const;

  template<typename Char, typename Traits, typename Allocator>
  bool operator()(const basic_string<Char, Traits, Allocator>&,
                  const basic_string<Char, Traits, Allocator>&) const;
  template<typename Char, typename Traits>
  bool operator()(basic_string_ref<Char, Traits>,
                  basic_string_ref<Char, Traits>) const;

  static locale global(const locale&);
  static const locale& classic();
  static const locale& posix();

 private:
  explicit locale(locale_t) noexcept;
  locale(const locale&, const id*, const facet*);
  bool has_facet_(const id*) const noexcept;
  const facet& use_facet_(const id*) const;

  locale_t data_ = nullptr;
};

#if 0 // XXX fix type_traits
static_assert(!has_virtual_destructor<locale>::value,
              "Standard explicitly mandates locale has a non-virtual "
              "destructor.");
#endif


class locale::facet {
#ifdef _COMPILING_LOCALE
  friend class locale::facet_ptr;
#else
  friend class locale;  // Silence compiler warnings.
#endif

 protected:
  explicit facet(size_t = 0);
  virtual ~facet() noexcept;
  facet(const facet&) = delete;
  facet& operator=(const facet&) = delete;

 private:
  mutable atomic<uintptr_t> refs_;
};

class locale::id {
 public:
  constexpr id() = default;
  constexpr id(category cat) noexcept : cat(cat) {}
  id(const id&) = delete;
  void operator=(const id&) = delete;

  const category cat = none;
};


template<typename Char> bool isspace(Char, const locale&);
template<typename Char> bool isprint(Char, const locale&);
template<typename Char> bool iscntrl(Char, const locale&);
template<typename Char> bool isupper(Char, const locale&);
template<typename Char> bool islower(Char, const locale&);
template<typename Char> bool isalpha(Char, const locale&);
template<typename Char> bool isdigit(Char, const locale&);
template<typename Char> bool ispunct(Char, const locale&);
template<typename Char> bool isxdigit(Char, const locale&);
template<typename Char> bool isalnum(Char, const locale&);
template<typename Char> bool isgraph(Char, const locale&);
template<typename Char> bool isblank(Char, const locale&);
template<typename Char> Char toupper(Char, const locale&);
template<typename Char> Char tolower(Char, const locale&);

template<typename Codecvt, typename Elem = wchar_t,
         typename WideAlloc = allocator<Elem>,
         typename ByteAlloc = allocator<char>>
class wstring_convert;

template<typename Codecvt, typename Elem = wchar_t,
         typename Tr = char_traits<Elem>>
class wbuffer_convert;


class ctype_base {
 public:
  using mask = unsigned short;

  static constexpr mask space  = 0x001,
                        print  = 0x002,
                        cntrl  = 0x004,
                        upper  = 0x008,
                        lower  = 0x010,
                        alpha  = 0x020,
                        digit  = 0x040,
                        punct  = 0x080,
                        xdigit = 0x100,
                        blank  = 0x200,
                        graph  = 0x400,
                        alnum  = alpha | digit;
};

template<typename Char>
class ctype
: public locale::facet,
  public ctype_base
{
 public:
  using char_type = Char;

  explicit ctype(size_t = 0);

  bool is(mask, char_type) const;
  const char_type* is(const char_type*, const char_type*, mask*) const;
  const char_type* scan_is(mask, const char_type*, const char_type*) const;
  const char_type* scan_not(mask, const char_type*, const char_type*) const;
  char_type toupper(char_type) const;
  const char_type* toupper(char_type*, const char_type*) const;
  char_type tolower(char_type) const;
  const char_type* tolower(char_type*, const char_type*) const;

  char_type widen(char) const;
  const char* widen(const char*, const char*, char_type*) const;
  char narrow(char_type, char) const;
  const char_type* narrow(const char_type*, const char_type*, char, char*)
      const;

  static constexpr locale::id id{ locale::ctype };

 protected:
  ~ctype() noexcept override;

  virtual bool do_is(mask, char_type) const;
  virtual const char_type* do_is(const char_type*, const char_type*, mask*)
      const;
  virtual const char_type* do_scan_is(mask, const char_type*, const char_type*)
      const;
  virtual const char_type* do_scan_not(mask,
                                       const char_type*, const char_type*)
      const;
  virtual char_type do_toupper(char_type) const;
  virtual const char_type* do_toupper(char_type*, const char_type*) const;
  virtual char_type do_tolower(char_type) const;
  virtual const char_type* do_tolower(char_type*, const char_type*) const;
  virtual char_type do_widen(char) const;
  virtual const char* do_widen(const char*, const char*, char_type*) const;
  virtual char do_narrow(char_type, char) const;
  virtual const char_type* do_narrow(const char_type*, const char_type*, char,
                                     char*) const;
};

template<> class ctype<char>
: public locale::facet,
  public ctype_base
{
 public:
  using char_type = char;

  explicit ctype(const mask* = nullptr, bool = false, size_t = 0);

  bool is(mask, char_type) const;
  const char_type* is(const char_type*, const char_type*, mask*) const;
  const char_type* scan_is(mask, const char_type*, const char_type*) const;
  const char_type* scan_not(mask, const char_type*, const char_type*) const;
  char_type toupper(char_type) const;
  const char_type* toupper(char_type*, const char_type*) const;
  char_type tolower(char_type) const;
  const char_type* tolower(char_type*, const char_type*) const;

  char_type widen(char) const;
  const char* widen(const char*, const char*, char_type*) const;
  char narrow(char_type, char) const;
  const char_type* narrow(const char_type*, const char_type*, char, char*)
      const;

  static constexpr locale::id id{ locale::ctype };
  static const size_t table_size;
  const mask* table() const noexcept;
  static const mask* classic_table() noexcept;

 protected:
  ~ctype() noexcept override;

  virtual char_type do_toupper(char_type) const;
  virtual const char_type* do_toupper(char_type*, const char_type*) const;
  virtual char_type do_tolower(char_type) const;
  virtual const char_type* do_tolower(char_type*, const char_type*) const;
  virtual char_type do_widen(char) const;
  virtual const char* do_widen(const char*, const char*, char_type*) const;
  virtual char do_narrow(char_type, char) const;
  virtual const char_type* do_narrow(const char_type*, const char_type*, char,
                                     char*) const;

 private:
  const mask* tbl_;
  bool del_;
};

template<typename Char>
class ctype_byname
: public ctype<Char>
{
 public:
  using mask = typename ctype<Char>::mask;
  explicit ctype_byname(const char*, size_t = 0);
  explicit ctype_byname(const string&, size_t = 0);
  explicit ctype_byname(string_ref, size_t = 0);

 protected:
  ~ctype_byname() noexcept = default;

 private:
  string name_;
};


class codecvt_base;
template<typename Intern, typename Extern, typename St> class codecvt;
template<typename Intern, typename Extern, typename St> class codecvt_byname;

template<typename Char, typename InputIter = istreambuf_iterator<Char>>
class num_get;
template<typename Char, typename OutputIter = ostreambuf_iterator<Char>>
class num_put;
template<typename Char> class numpunct;
template<typename Char> class numpunct_byname;

template<typename Char> class collate;
template<typename Char> class collate_byname;

class time_base;
template<typename Char, typename InputIter = istreambuf_iterator<Char>>
class time_get;
template<typename Char, typename InputIter = istreambuf_iterator<Char>>
class time_get_byname;
template<typename Char, typename OutputIter = ostreambuf_iterator<Char>>
class time_put;
template<typename Char, typename OutputIter = ostreambuf_iterator<Char>>
class time_put_byname;

class money_base;
template<typename Char, typename InputIter = istreambuf_iterator<Char>>
class money_get;
template<typename Char, typename OutputIter = ostreambuf_iterator<Char>>
class money_put;
template<typename Char, bool Intl = false> class moneypunct;
template<typename Char, bool Intl = false> class moneypunct_byname;

class messages_base;
template<typename Char> class messages;
template<typename Char> class messages_byname;


extern template bool locale::operator()(basic_string_ref<char>,
                                        basic_string_ref<char>) const;
extern template bool locale::operator()(basic_string_ref<char16_t>,
                                        basic_string_ref<char16_t>) const;
extern template bool locale::operator()(basic_string_ref<char32_t>,
                                        basic_string_ref<char32_t>) const;
extern template bool locale::operator()(basic_string_ref<wchar_t>,
                                        basic_string_ref<wchar_t>) const;


extern template class ctype<char16_t>;
extern template class ctype<char32_t>;
extern template class ctype<wchar_t>;


_namespace_end(std)

#include <locale-inl.h>

#endif /* _LOCALE_ */
