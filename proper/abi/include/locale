#ifndef _LOCALE_
#define _LOCALE_

#include <locale-fwd.h>
#include <cdecl.h>
#include <iosfwd>
#include <type_traits>
#include <string>
#include <locale_misc/lc_mask.h>
#include <locale_misc/locale_t.h>

#ifdef _COMPILING_LOCALE
# include <clocale>
#endif

_namespace_begin(std)


template<typename Facet> const Facet& use_facet(const locale&);
template<typename Facet> bool has_facet(const locale&) noexcept;


class locale {
  friend void swap(locale&, locale&) noexcept;  // extension

  template<typename Facet> friend const Facet& use_facet(const locale&);
  template<typename Facet> friend bool has_facet(const locale&) noexcept;
#ifdef _COMPILING_LOCALE
  friend locale_t newlocale(int, const char*, locale_t) noexcept;
  friend locale_t uselocale(locale_t) noexcept;
  friend char* setlocale(int, const char*) noexcept;
#endif

 public:
  class facet;
  class id;
  using category = int;
#ifdef _COMPILING_LOCALE
  class facet_ptr;
#endif

  static constexpr category none     = 0,
                            collate  = LC_COLLATE_MASK,
                            ctype    = LC_CTYPE_MASK,
                            monetary = LC_MONETARY_MASK,
                            numeric  = LC_NUMERIC_MASK,
                            time     = LC_TIME_MASK,
                            messages = LC_MESSAGES_MASK,
                            all      = LC_ALL_MASK;

  locale() noexcept;
  locale(const locale&) noexcept;
  locale(locale&&) noexcept;
  explicit locale(const char*);
  explicit locale(const string&);
  explicit locale(string_ref);
  locale(const locale&, const char*, category);
  locale(const locale&, const string&, category);
  locale(const locale&, string_ref, category);
  template<typename Facet> locale(const locale&, Facet*);
  locale(const locale&, const locale&, category);
  ~locale() noexcept;

  const locale& operator=(const locale&) noexcept;
  const locale& operator=(locale&&) noexcept;
  template<typename Facet> locale combine(const locale&) const;

  string name() const;

  bool operator==(const locale&) const;
  bool operator!=(const locale&) const;

  template<typename Char, typename Traits, typename Allocator>
  bool operator()(const basic_string<Char, Traits, Allocator>&,
                  const basic_string<Char, Traits, Allocator>&) const;
  template<typename Char, typename Traits>
  bool operator()(basic_string_ref<Char, Traits>,
                  basic_string_ref<Char, Traits>) const;

  static locale global(const locale&);
  static const locale& classic();
  static const locale& posix();

 private:
  explicit locale(locale_t) noexcept;
  locale(const locale&, const id*, const facet*);
  const facet* has_facet_(const id*) const noexcept;
  const facet& use_facet_(const id*) const;

  locale_t data_ = nullptr;
};

#if 0 // XXX fix type_traits
static_assert(!has_virtual_destructor<locale>::value,
              "Standard explicitly mandates locale has a non-virtual "
              "destructor.");
#endif


namespace impl {

template<typename Facet>
class facet_ref {
 protected:
  explicit facet_ref(locale);
  ~facet_ref() noexcept = default;

  locale loc;
  const Facet& impl;
};

} /* namespace std::impl */


class locale::facet {
#ifdef _COMPILING_LOCALE
  friend class locale::facet_ptr;
#else
  friend class locale;  // Silence compiler warnings.
#endif

 protected:
  explicit facet(size_t = 0);
  virtual ~facet() noexcept;
  facet(const facet&) = delete;
  facet& operator=(const facet&) = delete;

 private:
  mutable atomic<uintptr_t> refs_;
};

class locale::id {
 public:
  constexpr id() = default;
  constexpr id(category cat) noexcept : cat(cat) {}
  id(const id&) = delete;
  void operator=(const id&) = delete;

  const category cat = none;
};


template<typename Char> bool isspace(Char, const locale&);
template<typename Char> bool isprint(Char, const locale&);
template<typename Char> bool iscntrl(Char, const locale&);
template<typename Char> bool isupper(Char, const locale&);
template<typename Char> bool islower(Char, const locale&);
template<typename Char> bool isalpha(Char, const locale&);
template<typename Char> bool isdigit(Char, const locale&);
template<typename Char> bool ispunct(Char, const locale&);
template<typename Char> bool isxdigit(Char, const locale&);
template<typename Char> bool isalnum(Char, const locale&);
template<typename Char> bool isgraph(Char, const locale&);
template<typename Char> bool isblank(Char, const locale&);
template<typename Char> Char toupper(Char, const locale&);
template<typename Char> Char tolower(Char, const locale&);

template<typename Codecvt, typename Elem = wchar_t,
         typename WideAlloc = allocator<Elem>,
         typename ByteAlloc = allocator<char>>
class wstring_convert;

template<typename Codecvt, typename Elem = wchar_t,
         typename Tr = char_traits<Elem>>
class wbuffer_convert;


class ctype_base {
 public:
  using mask = unsigned short;

  static constexpr mask space  = 0x001,
                        print  = 0x002,
                        cntrl  = 0x004,
                        upper  = 0x008,
                        lower  = 0x010,
                        alpha  = 0x020,
                        digit  = 0x040,
                        punct  = 0x080,
                        xdigit = 0x100,
                        blank  = 0x200,
                        graph  = 0x400,
                        alnum  = alpha | digit;
};

template<typename Char>
class ctype
: public locale::facet,
  public ctype_base
{
 public:
  using char_type = Char;

  explicit ctype(size_t = 0);

  bool is(mask, char_type) const;
  const char_type* is(const char_type*, const char_type*, mask*) const;
  const char_type* scan_is(mask, const char_type*, const char_type*) const;
  const char_type* scan_not(mask, const char_type*, const char_type*) const;
  char_type toupper(char_type) const;
  const char_type* toupper(char_type*, const char_type*) const;
  char_type tolower(char_type) const;
  const char_type* tolower(char_type*, const char_type*) const;

  char_type widen(char) const;
  const char* widen(const char*, const char*, char_type*) const;
  char narrow(char_type, char) const;
  const char_type* narrow(const char_type*, const char_type*, char, char*)
      const;

  static const locale::id id;

 protected:
  ~ctype() noexcept override;

  virtual bool do_is(mask, char_type) const = 0;
  virtual const char_type* do_is(const char_type*, const char_type*, mask*)
      const = 0;
  virtual const char_type* do_scan_is(mask, const char_type*, const char_type*)
      const = 0;
  virtual const char_type* do_scan_not(mask,
                                       const char_type*, const char_type*)
      const = 0;
  virtual char_type do_toupper(char_type) const = 0;
  virtual const char_type* do_toupper(char_type*, const char_type*) const = 0;
  virtual char_type do_tolower(char_type) const = 0;
  virtual const char_type* do_tolower(char_type*, const char_type*) const = 0;
  virtual char_type do_widen(char) const = 0;
  virtual const char* do_widen(const char*, const char*, char_type*) const = 0;
  virtual char do_narrow(char_type, char) const = 0;
  virtual const char_type* do_narrow(const char_type*, const char_type*, char,
                                     char*) const = 0;
};

template<typename Char> const locale::id ctype<Char>::id{ locale::ctype };

template<> class ctype<char>
: public locale::facet,
  public ctype_base
{
 public:
  using char_type = char;

  explicit ctype(const mask* = nullptr, bool = false, size_t = 0);

  bool is(mask, char_type) const;
  const char_type* is(const char_type*, const char_type*, mask*) const;
  const char_type* scan_is(mask, const char_type*, const char_type*) const;
  const char_type* scan_not(mask, const char_type*, const char_type*) const;
  char_type toupper(char_type) const;
  const char_type* toupper(char_type*, const char_type*) const;
  char_type tolower(char_type) const;
  const char_type* tolower(char_type*, const char_type*) const;

  char_type widen(char) const;
  const char* widen(const char*, const char*, char_type*) const;
  char narrow(char_type, char) const;
  const char_type* narrow(const char_type*, const char_type*, char, char*)
      const;

  static constexpr locale::id id{ locale::ctype };
  static const size_t table_size;
  const mask* table() const noexcept;
  static const mask* classic_table() noexcept;

 protected:
  ~ctype() noexcept override;

  virtual char_type do_toupper(char_type) const;
  virtual const char_type* do_toupper(char_type*, const char_type*) const;
  virtual char_type do_tolower(char_type) const;
  virtual const char_type* do_tolower(char_type*, const char_type*) const;
  virtual char_type do_widen(char) const;
  virtual const char* do_widen(const char*, const char*, char_type*) const;
  virtual char do_narrow(char_type, char) const;
  virtual const char_type* do_narrow(const char_type*, const char_type*, char,
                                     char*) const;

 private:
  const mask* tbl_;
  bool del_;
};

template<>
class ctype<char16_t>
: public locale::facet,
  public ctype_base
{
 public:
  using char_type = char16_t;

  explicit ctype(size_t = 0);

  bool is(mask, char_type) const;
  const char_type* is(const char_type*, const char_type*, mask*) const;
  const char_type* scan_is(mask, const char_type*, const char_type*) const;
  const char_type* scan_not(mask, const char_type*, const char_type*) const;
  char_type toupper(char_type) const;
  const char_type* toupper(char_type*, const char_type*) const;
  char_type tolower(char_type) const;
  const char_type* tolower(char_type*, const char_type*) const;

  char_type widen(char) const;
  const char* widen(const char*, const char*, char_type*) const;
  char narrow(char_type, char) const;
  const char_type* narrow(const char_type*, const char_type*, char, char*)
      const;

  static constexpr locale::id id{ locale::ctype };

 protected:
  ~ctype() noexcept override;

  virtual bool do_is(mask, char_type) const;
  virtual const char_type* do_is(const char_type*, const char_type*, mask*)
      const;
  virtual const char_type* do_scan_is(mask, const char_type*, const char_type*)
      const;
  virtual const char_type* do_scan_not(mask,
                                       const char_type*, const char_type*)
      const;
  virtual char_type do_toupper(char_type) const;
  virtual const char_type* do_toupper(char_type*, const char_type*) const;
  virtual char_type do_tolower(char_type) const;
  virtual const char_type* do_tolower(char_type*, const char_type*) const;
  virtual char_type do_widen(char) const;
  virtual const char* do_widen(const char*, const char*, char_type*) const;
  virtual char do_narrow(char_type, char) const;
  virtual const char_type* do_narrow(const char_type*, const char_type*, char,
                                     char*) const;
};

template<>
class ctype<char32_t>
: public locale::facet,
  public ctype_base
{
 public:
  using char_type = char32_t;

  explicit ctype(size_t = 0);

  bool is(mask, char_type) const;
  const char_type* is(const char_type*, const char_type*, mask*) const;
  const char_type* scan_is(mask, const char_type*, const char_type*) const;
  const char_type* scan_not(mask, const char_type*, const char_type*) const;
  char_type toupper(char_type) const;
  const char_type* toupper(char_type*, const char_type*) const;
  char_type tolower(char_type) const;
  const char_type* tolower(char_type*, const char_type*) const;

  char_type widen(char) const;
  const char* widen(const char*, const char*, char_type*) const;
  char narrow(char_type, char) const;
  const char_type* narrow(const char_type*, const char_type*, char, char*)
      const;

  static constexpr locale::id id{ locale::ctype };

 protected:
  ~ctype() noexcept override;

  virtual bool do_is(mask, char_type) const;
  virtual const char_type* do_is(const char_type*, const char_type*, mask*)
      const;
  virtual const char_type* do_scan_is(mask, const char_type*, const char_type*)
      const;
  virtual const char_type* do_scan_not(mask,
                                       const char_type*, const char_type*)
      const;
  virtual char_type do_toupper(char_type) const;
  virtual const char_type* do_toupper(char_type*, const char_type*) const;
  virtual char_type do_tolower(char_type) const;
  virtual const char_type* do_tolower(char_type*, const char_type*) const;
  virtual char_type do_widen(char) const;
  virtual const char* do_widen(const char*, const char*, char_type*) const;
  virtual char do_narrow(char_type, char) const;
  virtual const char_type* do_narrow(const char_type*, const char_type*, char,
                                     char*) const;
};

template<>
class ctype<wchar_t>
: public locale::facet,
  public ctype_base
{
 public:
  using char_type = wchar_t;

  explicit ctype(size_t = 0);

  bool is(mask, char_type) const;
  const char_type* is(const char_type*, const char_type*, mask*) const;
  const char_type* scan_is(mask, const char_type*, const char_type*) const;
  const char_type* scan_not(mask, const char_type*, const char_type*) const;
  char_type toupper(char_type) const;
  const char_type* toupper(char_type*, const char_type*) const;
  char_type tolower(char_type) const;
  const char_type* tolower(char_type*, const char_type*) const;

  char_type widen(char) const;
  const char* widen(const char*, const char*, char_type*) const;
  char narrow(char_type, char) const;
  const char_type* narrow(const char_type*, const char_type*, char, char*)
      const;

  static constexpr locale::id id{ locale::ctype };

 protected:
  ~ctype() noexcept override;

  virtual bool do_is(mask, char_type) const;
  virtual const char_type* do_is(const char_type*, const char_type*, mask*)
      const;
  virtual const char_type* do_scan_is(mask, const char_type*, const char_type*)
      const;
  virtual const char_type* do_scan_not(mask,
                                       const char_type*, const char_type*)
      const;
  virtual char_type do_toupper(char_type) const;
  virtual const char_type* do_toupper(char_type*, const char_type*) const;
  virtual char_type do_tolower(char_type) const;
  virtual const char_type* do_tolower(char_type*, const char_type*) const;
  virtual char_type do_widen(char) const;
  virtual const char* do_widen(const char*, const char*, char_type*) const;
  virtual char do_narrow(char_type, char) const;
  virtual const char_type* do_narrow(const char_type*, const char_type*, char,
                                     char*) const;
};

template<typename Char>
class ctype_byname
: public ctype<Char>,
  private impl::facet_ref<ctype<Char>>
{
 public:
  using mask = typename ctype<Char>::mask;
  using char_type = typename ctype<Char>::char_type;

  explicit ctype_byname(const char*, size_t = 0);
  explicit ctype_byname(const string&, size_t = 0);
  explicit ctype_byname(string_ref, size_t = 0);

 protected:
  ~ctype_byname() noexcept override = default;

  bool do_is(mask, char_type) const override;
  const char_type* do_is(const char_type*, const char_type*, mask*)
      const override;
  const char_type* do_scan_is(mask, const char_type*, const char_type*)
      const override;
  const char_type* do_scan_not(mask, const char_type*, const char_type*)
      const override;
  char_type do_toupper(char_type) const override;
  const char_type* do_toupper(char_type*, const char_type*) const override;
  char_type do_tolower(char_type) const override;
  const char_type* do_tolower(char_type*, const char_type*) const override;
  char_type do_widen(char) const override;
  const char* do_widen(const char*, const char*, char_type*) const override;
  char do_narrow(char_type, char) const override;
  const char_type* do_narrow(const char_type*, const char_type*, char,
                             char*) const override;
};

template<>
class ctype_byname<char>
: private impl::facet_ref<ctype<char>>,
  public ctype<char>
{
 public:
  using mask = typename ctype<char>::mask;
  using char_type = typename ctype<char>::char_type;

  explicit ctype_byname(const char*, size_t = 0);
  explicit ctype_byname(const string&, size_t = 0);
  explicit ctype_byname(string_ref, size_t = 0);

 protected:
  ~ctype_byname() noexcept override;

  char_type do_toupper(char_type) const override;
  const char_type* do_toupper(char_type*, const char_type*) const override;
  char_type do_tolower(char_type) const override;
  const char_type* do_tolower(char_type*, const char_type*) const override;
  char_type do_widen(char) const override;
  const char* do_widen(const char*, const char*, char_type*) const override;
  char do_narrow(char_type, char) const override;
  const char_type* do_narrow(const char_type*, const char_type*, char,
                             char*) const override;
};


class codecvt_base {
 public:
  enum result {
    ok,
    partial,
    error,
    noconv
  };
};

template<typename Intern, typename Extern, typename St>
class codecvt
: public locale::facet,
  public codecvt_base
{
 public:
  using intern_type = Intern;
  using extern_type = Extern;
  using state_type = St;

  explicit codecvt(size_t = 0);

  result out(state_type&,
             const intern_type*, const intern_type*, const intern_type*&,
             extern_type*, extern_type*, extern_type*&) const;
  result in(state_type&,
            const extern_type*, const extern_type*, const extern_type*&,
            intern_type*, intern_type*, intern_type*&) const;
  result unshift(state_type&,
                 extern_type*, extern_type*, extern_type*&) const;
  int encoding() const noexcept;
  bool always_noconv() const noexcept;
  int length(state_type&, const extern_type*, const extern_type*,
             size_t) const;
  int max_length() const noexcept;

  static const locale::id id;

 protected:
  ~codecvt() noexcept override;

  virtual result do_out(state_type&,
                        const intern_type*, const intern_type*,
                        const intern_type*&,
                        extern_type*, extern_type*, extern_type*&) const;
  virtual result do_in(state_type&,
                       const extern_type*, const extern_type*,
                       const extern_type*&,
                       intern_type*, intern_type*, intern_type*&) const;
  virtual result do_unshift(state_type&,
                            extern_type*, extern_type*, extern_type*&) const;
  virtual int do_encoding() const noexcept;
  virtual bool do_always_noconv() const noexcept;
  virtual int do_length(state_type&, const extern_type*, const extern_type*,
                        size_t) const;
  virtual int do_max_length() const noexcept;
};

template<typenaem Intern, typename Extern, typename St>
const locale::id codecvt<Intern, Extern, St>::id{ locale::codecvt };

template<typename Intern, typename Extern, typename St>
class codecvt_byname
: public codecvt<Intern, Extern, St>,
  private impl::facet_ref<codecvt<Intern, Extern, St>>
{
 public:
  using intern_type = typename codecvt<Intern, Extern, St>::intern_type;
  using extern_type = typename codecvt<Intern, Extern, St>::extern_type;
  using state_type = typename codecvt<Intern, Extern, St>::state_type;
  using result = typename codecvt<Intern, Extern, St>::result;

  explicit codecvt_byname(const char*, size_t = 0);
  explicit codecvt_byname(const string&, size_t = 0);
  explicit codecvt_byname(string_ref, size_t = 0);

 protected:
  ~codecvt_byname() noexcept override = default;

  result do_out(state_type&,
                const intern_type*, const intern_type*,
                const intern_type*&,
                extern_type*, extern_type*, extern_type*&) const override;
  result do_in(state_type&,
               const extern_type*, const extern_type*,
               const extern_type*&,
               intern_type*, intern_type*, intern_type*&) const override;
  result do_unshift(state_type&,
                    extern_type*, extern_type*, extern_type*&) const override;
  int do_encoding() const noexcept override;
  bool do_always_noconv() const noexcept override;
  int do_length(state_type&, const extern_type*, const extern_type*,
                size_t) const override;
  int do_max_length() const noexcept override;
};

template<typename Char, typename InputIter>
class num_get;

template<typename Char, typename OutputIter>
class num_put
: public locale::facet
{
 public:
  using char_type = Char;
  using iter_type = OutputIter;

  explicit num_put(size_t = 0);

  iter_type put(iter_type, ios_base&, char_type, bool) const;
  iter_type put(iter_type, ios_base&, char_type, long) const;
  iter_type put(iter_type, ios_base&, char_type, long long) const;
  iter_type put(iter_type, ios_base&, char_type, unsigned long) const;
  iter_type put(iter_type, ios_base&, char_type, unsigned long long) const;
#if _USE_INT128
  iter_type put(iter_type, ios_base&, char_type, int128_t) const;
  iter_type put(iter_type, ios_base&, char_type, uint128_t) const;
#endif
  iter_type put(iter_type, ios_base&, char_type, double) const;
  iter_type put(iter_type, ios_base&, char_type, long double) const;
  iter_type put(iter_type, ios_base&, char_type, const void*) const;

  static const locale::id id;

 protected:
  ~num_put() noexcept override;

  virtual iter_type do_put(iter_type, ios_base&, char_type, bool) const;
  virtual iter_type do_put(iter_type, ios_base&, char_type, long) const;
  virtual iter_type do_put(iter_type, ios_base&, char_type, long long) const;
  virtual iter_type do_put(iter_type, ios_base&, char_type, unsigned long)
      const;
  virtual iter_type do_put(iter_type, ios_base&, char_type, unsigned long long)
      const;
#if _USE_INT128
  virtual iter_type do_put(iter_type, ios_base&, char_type, int128_t) const;
  virtual iter_type do_put(iter_type, ios_base&, char_type, uint128_t) const;
#endif
  virtual iter_type do_put(iter_type, ios_base&, char_type, double) const;
  virtual iter_type do_put(iter_type, ios_base&, char_type, long double) const;
  virtual iter_type do_put(iter_type, ios_base&, char_type, const void*) const;
};

template<typename Char, typename OutputIter>
const locale::id num_put<Char, OutputIter>::id{ locale::collate };


template<typename Char> class numpunct;

template<>
class numpunct<char>
: public locale::facet
{
 public:
  using char_type = char;
  using string_type = basic_string<char_type>;

  explicit numpunct(size_t = 0);

  char_type decimal_point() const;
  char_type thousands_sep() const;
  string grouping() const;
  string_type truename() const;
  string_type falsename() const;

  static constexpr locale::id id{ locale::numeric };

 protected:
  ~numpunct() noexcept override;

  virtual char_type do_decimal_point() const;
  virtual char_type do_thousands_sep() const;
  virtual string do_grouping() const;
  virtual string_type do_truename() const;
  virtual string_type do_falsename() const;
};

template<>
class numpunct<char16_t>
: public locale::facet
{
 public:
  using char_type = char16_t;
  using string_type = basic_string<char_type>;

  explicit numpunct(size_t = 0);

  char_type decimal_point() const;
  char_type thousands_sep() const;
  string grouping() const;
  string_type truename() const;
  string_type falsename() const;

  static constexpr locale::id id{ locale::numeric };

 protected:
  ~numpunct() noexcept override;

  virtual char_type do_decimal_point() const;
  virtual char_type do_thousands_sep() const;
  virtual string do_grouping() const;
  virtual string_type do_truename() const;
  virtual string_type do_falsename() const;
};

template<>
class numpunct<char32_t>
: public locale::facet
{
 public:
  using char_type = char32_t;
  using string_type = basic_string<char_type>;

  explicit numpunct(size_t = 0);

  char_type decimal_point() const;
  char_type thousands_sep() const;
  string grouping() const;
  string_type truename() const;
  string_type falsename() const;

  static constexpr locale::id id{ locale::numeric };

 protected:
  ~numpunct() noexcept override;

  virtual char_type do_decimal_point() const;
  virtual char_type do_thousands_sep() const;
  virtual string do_grouping() const;
  virtual string_type do_truename() const;
  virtual string_type do_falsename() const;
};

template<>
class numpunct<wchar_t>
: public locale::facet
{
 public:
  using char_type = wchar_t;
  using string_type = basic_string<char_type>;

  explicit numpunct(size_t = 0);

  char_type decimal_point() const;
  char_type thousands_sep() const;
  string grouping() const;
  string_type truename() const;
  string_type falsename() const;

  static constexpr locale::id id{ locale::numeric };

 protected:
  ~numpunct() noexcept override;

  virtual char_type do_decimal_point() const;
  virtual char_type do_thousands_sep() const;
  virtual string do_grouping() const;
  virtual string_type do_truename() const;
  virtual string_type do_falsename() const;
};

template<typename Char>
class numpunct_byname
: public numpunct<Char>,
  private impl::facet_ref<numpunct<Char>>
{
 public:
  using char_type = typename numpunct<Char>::char_type;
  using string_type = typename numpunct<Char>::string_type;

  explicit numpunct_byname(const char*, size_t = 0);
  explicit numpunct_byname(const string&, size_t = 0);
  explicit numpunct_byname(string_ref, size_t = 0);

 protected:
  ~numpunct_byname() noexcept override = default;

  char_type do_decimal_point() const override;
  char_type do_thousands_sep() const override;
  string do_grouping() const override;
  string_type do_truename() const override;
  string_type do_falsename() const override;
};

template<typename Char>
class collate
: public locale::facet
{
 public:
  using char_type = Char;
  using string_type = basic_string<Char>;

  explicit collate(size_t = 0);

  int compare(const char_type*, const char_type*,
              const char_type*, const char_type*) const;
  string_type transform(const char_type*, const char_type*) const;
  long hash(const char_type*, const char_type*) const;

  static const locale::id id;

 protected:
  ~collate() noexcept override;

  virtual int do_compare(const char_type*, const char_type*,
                         const char_type*, const char_type*) const;
  virtual string_type do_transform(const char_type*, const char_type*) const;
  virtual long do_hash(const char_type*, const char_type*) const;
};

template<typename Char> const locale::id collate<Char>::id{ locale::collate };

template<typename Char>
class collate_byname
: public collate<Char>,
  private impl::facet_ref<collate<Char>>
{
 public:
  using char_type = typename collate<Char>::char_type;
  using string_type = typename collate<Char>::string_type;

  explicit collate_byname(const char*, size_t = 0);
  explicit collate_byname(const string&, size_t = 0);
  explicit collate_byname(string_ref, size_t = 0);

 protected:
  ~collate_byname() noexcept override = default;

  int do_compare(const char_type*, const char_type*,
                 const char_type*, const char_type*) const override;
  string_type do_transform(const char_type*, const char_type*) const override;
  long do_hash(const char_type*, const char_type*) const override;
};

class time_base;
template<typename Char, typename InputIter>
class time_get;
template<typename Char, typename InputIter = istreambuf_iterator<Char>>
class time_get_byname;
template<typename Char, typename OutputIter>
class time_put;
template<typename Char, typename OutputIter = ostreambuf_iterator<Char>>
class time_put_byname;

class money_base;
template<typename Char, typename InputIter>
class money_get;
template<typename Char, typename OutputIter>
class money_put;
template<typename Char, bool Intl> class moneypunct;
template<typename Char, bool Intl = false> class moneypunct_byname;

class messages_base {
 public:
  using catalog = int;
};

template<typename Char>
class messages
: public locale::facet,
  public messages_base
{
 public:
  using char_type = Char;
  using string_type = basic_string<char_type>;

  explicit messages(size_t = 0);

  catalog open(const string&, const locale&) const;
  string_type get(catalog, int, int, const string_type&) const;
  void close(catalog) const;

  static const locale::id id;

 protected:
  ~messages() noexcept override;

  virtual catalog do_open(const string&, const locale&) const = 0;
  virtual string_type do_get(catalog, int, int, const string_type&) const = 0;
  virtual void do_close(catalog) const = 0;
};

template<typename Char> const locale::id messages::id{ locale::messages };

template<typename Char>
class messages_byname
: public messages<Char>,
  private impl::facet_ref<messages<Char>>
{
 public:
  using catalog = typename messages<Char>::catalog;
  using char_type = typename messages<Char>::char_type;
  using string_type = typename messages<Char>::string_type;

  explicit messages_byname(const char*, size_t = 0);
  explicit messages_byname(const string&, size_t = 0);
  explicit messages_byname(string_ref, size_t = 0);

 protected:
  ~messages_byname() noexcept override = default;

  catalog do_open(const string&, const locale&) const override;
  string_type do_get(catalog, int, int, const string_type&) const override;
  void do_close(catalog) const override;
};


extern template bool locale::operator()(basic_string_ref<char>,
                                        basic_string_ref<char>) const;
extern template bool locale::operator()(basic_string_ref<char16_t>,
                                        basic_string_ref<char16_t>) const;
extern template bool locale::operator()(basic_string_ref<char32_t>,
                                        basic_string_ref<char32_t>) const;
extern template bool locale::operator()(basic_string_ref<wchar_t>,
                                        basic_string_ref<wchar_t>) const;


extern template class ctype_byname<char>;
extern template class ctype_byname<char16_t>;
extern template class ctype_byname<char32_t>;
extern template class ctype_byname<wchar_t>;

extern template class codecvt<char,     char,     mbstate_t>;
extern template class codecvt<char16_t, char,     mbstate_t>;
extern template class codecvt<char32_t, char,     mbstate_t>;
extern template class codecvt<wchar_t,  char,     mbstate_t>;
extern template class codecvt<char,     char16_t, mbstate_t>;
extern template class codecvt<char16_t, char16_t, mbstate_t>;
extern template class codecvt<char32_t, char16_t, mbstate_t>;
extern template class codecvt<wchar_t,  char16_t, mbstate_t>;
extern template class codecvt<char,     char32_t, mbstate_t>;
extern template class codecvt<char16_t, char32_t, mbstate_t>;
extern template class codecvt<char32_t, char32_t, mbstate_t>;
extern template class codecvt<wchar_t,  char32_t, mbstate_t>;
extern template class codecvt<char,     wchar_t,  mbstate_t>;
extern template class codecvt<char16_t, wchar_t,  mbstate_t>;
extern template class codecvt<char32_t, wchar_t,  mbstate_t>;
extern template class codecvt<wchar_t,  wchar_t,  mbstate_t>;

extern template class codecvt_byname<char,     char,     mbstate_t>;
extern template class codecvt_byname<char16_t, char,     mbstate_t>;
extern template class codecvt_byname<char32_t, char,     mbstate_t>;
extern template class codecvt_byname<wchar_t,  char,     mbstate_t>;
extern template class codecvt_byname<char,     char16_t, mbstate_t>;
extern template class codecvt_byname<char16_t, char16_t, mbstate_t>;
extern template class codecvt_byname<char32_t, char16_t, mbstate_t>;
extern template class codecvt_byname<wchar_t,  char16_t, mbstate_t>;
extern template class codecvt_byname<char,     char32_t, mbstate_t>;
extern template class codecvt_byname<char16_t, char32_t, mbstate_t>;
extern template class codecvt_byname<char32_t, char32_t, mbstate_t>;
extern template class codecvt_byname<wchar_t,  char32_t, mbstate_t>;
extern template class codecvt_byname<char,     wchar_t,  mbstate_t>;
extern template class codecvt_byname<char16_t, wchar_t,  mbstate_t>;
extern template class codecvt_byname<char32_t, wchar_t,  mbstate_t>;
extern template class codecvt_byname<wchar_t,  wchar_t,  mbstate_t>;

extern template class num_put<char>;
extern template class num_put<char16_t>;
extern template class num_put<char32_t>;
extern template class num_put<wchar_t>;

extern template class numpunct_byname<char>;
extern template class numpunct_byname<char16_t>;
extern template class numpunct_byname<char32_t>;
extern template class numpunct_byname<wchar_t>;

extern template class collate<char>;
extern template class collate<char16_t>;
extern template class collate<char32_t>;
extern template class collate<wchar_t>;

extern template class collate_byname<char>;
extern template class collate_byname<char16_t>;
extern template class collate_byname<char32_t>;
extern template class collate_byname<wchar_t>;

extern template class messages<char>;
extern template class messages<char16_t>;
extern template class messages<char32_t>;
extern template class messages<wchar_t>;

extern template class messages_byname<char>;
extern template class messages_byname<char16_t>;
extern template class messages_byname<char32_t>;
extern template class messages_byname<wchar_t>;


extern template bool isspace(char, const locale&);
extern template bool isprint(char, const locale&);
extern template bool iscntrl(char, const locale&);
extern template bool isupper(char, const locale&);
extern template bool islower(char, const locale&);
extern template bool isalpha(char, const locale&);
extern template bool isdigit(char, const locale&);
extern template bool ispunct(char, const locale&);
extern template bool isxdigit(char, const locale&);
extern template bool isalnum(char, const locale&);
extern template bool isgraph(char, const locale&);
extern template bool isblank(char, const locale&);
extern template char toupper(char, const locale&);
extern template char tolower(char, const locale&);

extern template bool isspace(char16_t, const locale&);
extern template bool isprint(char16_t, const locale&);
extern template bool iscntrl(char16_t, const locale&);
extern template bool isupper(char16_t, const locale&);
extern template bool islower(char16_t, const locale&);
extern template bool isalpha(char16_t, const locale&);
extern template bool isdigit(char16_t, const locale&);
extern template bool ispunct(char16_t, const locale&);
extern template bool isxdigit(char16_t, const locale&);
extern template bool isalnum(char16_t, const locale&);
extern template bool isgraph(char16_t, const locale&);
extern template bool isblank(char16_t, const locale&);
extern template char16_t toupper(char16_t, const locale&);
extern template char16_t tolower(char16_t, const locale&);

extern template bool isspace(char32_t, const locale&);
extern template bool isprint(char32_t, const locale&);
extern template bool iscntrl(char32_t, const locale&);
extern template bool isupper(char32_t, const locale&);
extern template bool islower(char32_t, const locale&);
extern template bool isalpha(char32_t, const locale&);
extern template bool isdigit(char32_t, const locale&);
extern template bool ispunct(char32_t, const locale&);
extern template bool isxdigit(char32_t, const locale&);
extern template bool isalnum(char32_t, const locale&);
extern template bool isgraph(char32_t, const locale&);
extern template bool isblank(char32_t, const locale&);
extern template char32_t toupper(char32_t, const locale&);
extern template char32_t tolower(char32_t, const locale&);

extern template bool isspace(wchar_t, const locale&);
extern template bool isprint(wchar_t, const locale&);
extern template bool iscntrl(wchar_t, const locale&);
extern template bool isupper(wchar_t, const locale&);
extern template bool islower(wchar_t, const locale&);
extern template bool isalpha(wchar_t, const locale&);
extern template bool isdigit(wchar_t, const locale&);
extern template bool ispunct(wchar_t, const locale&);
extern template bool isxdigit(wchar_t, const locale&);
extern template bool isalnum(wchar_t, const locale&);
extern template bool isgraph(wchar_t, const locale&);
extern template bool isblank(wchar_t, const locale&);
extern template wchar_t toupper(wchar_t, const locale&);
extern template wchar_t tolower(wchar_t, const locale&);


_namespace_end(std)

#ifndef _LOCALE_SKIP_INL_INCLUDE
# include <locale-inl.h>
#endif

#endif /* _LOCALE_ */
