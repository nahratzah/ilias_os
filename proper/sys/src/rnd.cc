/*
 * Copyright (c) 2015 Ariane van der Steldt
 * Copyright (c) 2011 Theo de Raadt.
 * Copyright (c) 2008 Damien Miller.
 * Copyright (c) 1996, 1997, 2000-2002 Michael Shalayeff.
 * Copyright (c) 2013 Markus Friedl.
 * Copyright Theodore Ts'o, 1994, 1995, 1996, 1997, 1998, 1999.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, and the entire permission notice in its entirety,
 *    including the disclaimer of warranties.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. The name of the author may not be used to endorse or promote
 *    products derived from this software without specific prior
 *    written permission.
 *
 * ALTERNATIVELY, this product may be distributed under the terms of
 * the GNU Public License, in which case the provisions of the GPL are
 * required INSTEAD OF the above restrictions.  (This clause is
 * necessary due to a potential bad interaction between the GPL and
 * the restrictions contained in a BSD-style copyright.)
 *
 * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESS OR IMPLIED
 * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT,
 * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
 * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED
 * OF THE POSSIBILITY OF SUCH DAMAGE.
 */

#include <cstddef>
#include <cstdlib>
#include <array>
#include <chrono>
#include <abi/memory.h>
#include <rnd.h>
#include <crypto/chacha.h>
#include <crypto/md5.h>

/*
 * Computers are very predictable devices.  Hence it is extremely hard
 * to produce truly random numbers on a computer --- as opposed to
 * pseudo-random numbers, which can be easily generated by using an
 * algorithm.  Unfortunately, it is very easy for attackers to guess
 * the sequence of pseudo-random number generators, and for some
 * applications this is not acceptable.  Instead, we must try to
 * gather "environmental noise" from the computer's environment, which
 * must be hard for outside attackers to observe and use to
 * generate random numbers.  In a Unix environment, this is best done
 * from inside the kernel.
 *
 * Sources of randomness from the environment include inter-keyboard
 * timings, inter-interrupt timings from some interrupts, and other
 * events which are both (a) non-deterministic and (b) hard for an
 * outside observer to measure.  Randomness from these sources is
 * added to the "rnd states" queue; this is used as much of the
 * source material which is mixed on occasion using a CRC-like function
 * into the "entropy pool".  This is not cryptographically strong, but
 * it is adequate assuming the randomness is not chosen maliciously,
 * and it very fast because the interrupt-time event is only to add
 * a small random token to the "rnd states" queue.
 *
 * When random bytes are desired, they are obtained by pulling from
 * the entropy pool and running a MD5 hash. The MD5 hash avoids
 * exposing the internal state of the entropy pool.  Even if it is
 * possible to analyze MD5 in some clever way, as long as the amount
 * of data returned from the generator is less than the inherent
 * entropy in the pool, the output data is totally unpredictable.  For
 * this reason, the routine decreases its internal estimate of how many
 * bits of "true randomness" are contained in the entropy pool as it
 * outputs random numbers.
 *
 * If this estimate goes to zero, the MD5 hash will continue to generate
 * output since there is no true risk because the MD5 output is not
 * exported outside this subsystem.  It is next used as input to seed a
 * RC4 stream cipher.  Attempts are made to follow best practice
 * regarding this stream cipher - the first chunk of output is discarded
 * and the cipher is re-seeded from time to time.  This design provides
 * very high amounts of output data from a potentially small entropy
 * base, at high enough speeds to encourage use of random numbers in
 * nearly any situation.
 *
 * The output of this single RC4 engine is then shared amongst many
 * consumers in the kernel and userland via a few interfaces:
 * arc4random_buf(), arc4random(), arc4random_uniform(), randomread()
 * for the set of /dev/random nodes, and the sysctl kern.arandom.
 *
 * Acknowledgements:
 * =================
 *
 * Ideas for constructing this random number generator were derived
 * from Pretty Good Privacy's random number generator, and from private
 * discussions with Phil Karn.  Colin Plumb provided a faster random
 * number generator, which speeds up the mixing function of the entropy
 * pool, taken from PGPfone.  Dale Worley has also contributed many
 * useful ideas and suggestions to improve this driver.
 *
 * Any flaws in the design are solely my responsibility, and should
 * not be attributed to the Phil, Colin, or any of the authors of PGP.
 *
 * Further background information on this topic may be obtained from
 * RFC 1750, "Randomness Recommendations for Security", by Donald
 * Eastlake, Steve Crocker, and Jeff Schiller.
 *
 * Using a RC4 stream cipher as 2nd stage after the MD5 output
 * is the result of work by David Mazieres.
 *
 * The code has been ported to C++ by Ariane.
 */

namespace ilias {
namespace rnd {


using namespace std;


namespace {


global_stats_group stats_rnd_grp{ nullptr, "rnd", {}, {} };
global_stats_group stats_rnd_arc4_grp{ &stats_rnd_grp, "arc4", {}, {} };
global_stats_group stats_rnd_queue_grp{ &stats_rnd_grp, "queue", {}, {} };
global_stats_group stats_rnd_src_grp{ &stats_rnd_grp, "source", {}, {} };

stats_counter rnd_total{ stats_rnd_grp, "total" };
stats_counter rnd_used{ stats_rnd_grp, "used" };
stats_counter arc4_reads{ stats_rnd_arc4_grp, "reads" };
stats_counter arc4_nstirs{ stats_rnd_arc4_grp, "nstirs" };
stats_counter rnd_enqs{ stats_rnd_queue_grp, "enqueue" };
stats_counter rnd_deqs{ stats_rnd_queue_grp, "dequeue" };
stats_counter rnd_drops{ stats_rnd_queue_grp, "drops" };
stats_counter rnd_drople{ stats_rnd_queue_grp, "drople" };
stats_histogram<32> rnd_ed{ stats_rnd_grp, "entropy" };


constexpr size_t POOLWORDS = 2048;
array<uint32_t, POOLWORDS> entropy_pool
    __attribute__((section(".openbsd.randomdata")));
constexpr size_t POOLBYTES = sizeof(entropy_pool);
constexpr size_t POOLMASK = (POOLBYTES - 1);
static_assert((POOLBYTES & POOLMASK) == 0, "POOLBYTES must be a power-of-2.");

constexpr array<size_t, 4> POOL_TAP{{ 1638, 1231, 819, 411 }};

mutex entropylock;


struct rand_event {
  entropy_source* re_state;
  unsigned int re_nbits,
               re_val;
  time_point re_time;
};
constexpr size_t QEVLEN = 1024 / sizeof(struct rand_event);
array<rand_event, QEVLEN> rnd_event_space;


constexpr size_t QEVSLOW = (QEVLEN * 3 / 4);
constexpr size_t QEVSBITS = 10;

auto rnd_event_head = rnd_event_space.begin();
auto rnd_event_tail = rnd_event_space.begin();

time_point rnd_timeout;
unsigned int entropy_add_ptr;
unsigned char entropy_input_rotate;


auto rnd_get() noexcept -> rand_event* {
  auto p = rnd_event_tail;
  if (p == rnd_event_head) return nullptr;

  if (next(p) == rnd_event_space.end())
    rnd_event_tail = rnd_event_space.begin();
  else
    ++rnd_event_tail;

  return &*p;
}

auto rnd_put() noexcept -> rand_event* {
  auto p = next(rnd_event_head);
  if (p == rnd_event_space.end())
    p = rnd_event_space.begin();
  if (p == rnd_event_tail) return nullptr;
  return rnd_event_tail = p;
}

auto rnd_qlen() noexcept -> size_t {
  auto len = rnd_event_head - rnd_event_tail;
  return (len < 0 ? -len : len);
}


/*
 * This function adds a byte into the entropy pool.  It does not
 * update the entropy estimate.  The caller must do this if appropriate.
 *
 * The pool is stirred with a polynomial of degree POOLWORDS over GF(2);
 * see POOL_TAP[1-4] above.
 */
template<typename Iter>
auto add_entropy_words(Iter b, Iter e) noexcept -> void {
  /* derived from IEEE 802.3 CRC-32 */
  static constexpr array<uint32_t, 8> twist_table{{
    0x00000000, 0x3b6e20c8, 0x76dc4190, 0x4db26158,
    0xedb88320, 0xd6d6a3e8, 0x9b64c2b0, 0xa00ae278
  }};

  for_each(b, e,
           [](uint32_t v) {
             uint32_t w = (v << entropy_input_rotate) |
                          (v >> (32 - entropy_input_rotate));
             uint32_t i = entropy_add_ptr =
                 (entropy_add_ptr - 1) & POOLMASK;
             /*
              * Normally, we add 7 bits of rotation to the pool.
              * At the beginning of the pool, add an extra 7 bits
              * rotation, so that successive passes spread the
              * input bits across the pool evenly.
              */
             entropy_input_rotate =
                 (entropy_input_rotate + (i ? 7 : 14)) & 31;

             /* XOR pool contents corresponding to polynomial terms */
             w ^= entropy_pool[(i + POOL_TAP[1]) & POOLMASK] ^
                  entropy_pool[(i + POOL_TAP[2]) & POOLMASK] ^
                  entropy_pool[(i + POOL_TAP[3]) & POOLMASK] ^
                  entropy_pool[(i + POOL_TAP[4]) & POOLMASK] ^
                  entropy_pool[(i + 1) & POOLMASK] ^
                  entropy_pool[i]; /* + 2^POOLWORDS */

             entropy_pool[i] = (w >> 3) ^ twist_table[w & 7];
           });
}

auto add_entropy_string(string_ref s) noexcept -> void {
  while (s.length() >= 4) {
    uint32_t v = (static_cast<uint32_t>(s[0]) << 24) |
                 (static_cast<uint32_t>(s[1]) << 16) |
                 (static_cast<uint32_t>(s[2]) <<  8) |
                 (static_cast<uint32_t>(s[3]) <<  0);
    add_entropy_words(&v, &v + 1U);
    s.remove_prefix(4);
  }
}

/*
 * Pulls entropy out of the queue and throws merges it into the pool
 * with the CRC.
 */
auto dequeue_randomness() noexcept -> void {
  unique_lock<mutex> lck{ entropylock };

#if 0
  if (timeout_initialized(&rnd_timeout))
    timeout_del(&rnd_timeout);
#endif

  rnd_deqs.add(1);
  for (rand_event* rep = rnd_get(); rep != nullptr; rep = rnd_get()) {
    auto re_time_count = rep->re_time.time_since_epoch().count();
    constexpr auto rtc_words = sizeof(re_time_count) / sizeof(uint32_t);

    array<uint32_t, 1 + rtc_words> buf;
    for (size_t i = 0; i < rtc_words; ++i) {
      buf[1 + i] = re_time_count & 0xffffffffU;
      re_time_count >>= 32;
    }
    buf[0] = rep->re_val;

    unsigned int nbits = rep->re_nbits;
    lck.unlock();

    add_entropy_words(buf.begin(), buf.end());

    lck.lock();
    rnd_total.add(nbits);
  }
}

/*
 * Grabs a chunk from the entropy_pool[] and slams it through MD5 when
 * requested.
 */
auto extract_entropy(uint8_t* buf, size_t nbytes) noexcept -> void {
  static array<uint32_t, POOLWORDS> extract_pool;
  crypto::md5::digest_type buffer;

  add_timer_randomness(nbytes);

  while (nbytes) {
    const auto len = min(nbytes, buffer.size());

    /*
     * INTENTIONALLY not protected by entropylock.  Races
     * during copy() result in acceptable input data; races
     * during MD5Update() would create nasty data dependencies.
     */
    copy(entropy_pool.begin(), entropy_pool.end(), extract_pool.begin());

    buffer = crypto::md5::calculate(
        reinterpret_cast<uint8_t*>(extract_pool.data()),
        sizeof(extract_pool));

    /* Copy data to destination buffer */
    copy_n(buffer.begin(), len, buf);
    nbytes -= len;
    buf += len;

    /* Modify pool so next hash will produce different results */
    add_timer_randomness(nbytes);
    dequeue_randomness();
  }

  /* Wipe data from memory */
  abi::safe_memzero(extract_pool.data(), sizeof(extract_pool));
  abi::safe_memzero(buffer.data(), buffer.size());
}


/* random keystream by ChaCha */

mutex rndlock;

constexpr size_t KEYSZ = 32;
constexpr size_t IVSZ = 8;
constexpr size_t BLOCKSZ = 64;
constexpr size_t RSBUFSZ = 16 * BLOCKSZ;

crypto::chacha rs;  // chacha context for random keystream

/* keystream blocks (also chacha seed from boot) */
array<uint8_t, RSBUFSZ> rs_buf __attribute__((section(".openbsd.randomdata")));
size_t rs_have;
size_t rs_count;

auto _rs_init(uint8_t* buf, size_t n) noexcept -> void {
  assert(n >= KEYSZ + IVSZ);
  rs.keysetup(buf, KEYSZ * 8, 0);
  rs.ivsetup(buf + KEYSZ);
}

auto _rs_rekey(uint8_t* dat, size_t datlen) noexcept -> void {
  fill(rs_buf.begin(), rs_buf.end(), 0);

  /* fill rs_buf with the keystream */
  rs.encrypt_bytes(rs_buf.data(), rs_buf.data(), rs_buf.size());
  /* mix in optional user provided data */
  if (dat) {
    size_t m = min(datlen, KEYSZ + IVSZ);
    for (size_t i = 0; i < m; ++i)
      rs_buf[i] ^= dat[i];
  }
  /* immediately reinit for backtracking resistance */
  _rs_init(rs_buf.data(), KEYSZ + IVSZ);
  fill(rs_buf.begin(), rs_buf.begin() + KEYSZ + IVSZ, 0);
  rs_have = RSBUFSZ - KEYSZ - IVSZ;
}

auto _rs_seed(uint8_t* buf, size_t n) -> void {
  _rs_rekey(buf, n);

  /* invalidate rs_buf */
  rs_have = 0;
  fill(rs_buf.begin(), rs_buf.end(), 0);
  rs_count = 1600000;
}

auto _rs_stir(bool do_lock) noexcept -> void {
  unique_lock<mutex> lck{ rndlock, defer_lock };
  array<uint8_t, KEYSZ + IVSZ> buf;

  /*
   * Use MD5 PRNG data and a system timespec; early in the boot
   * process this is the best we can do -- some architectures do
   * not collect entropy very well during this time, but may have
   * clock information which is better than nothing.
   */
  extract_entropy(buf.data(), buf.size());
  {
    const time_point ts = clock_type::now();
    transform(buf.begin(), buf.begin() + min(buf.size(), sizeof(ts)),
              reinterpret_cast<const uint8_t*>(&ts),
              buf.begin(),
              [](uint8_t x, uint8_t y) { return x ^ y; });
  }

  if (do_lock) lck.lock();

  _rs_seed(buf.data(), buf.size());
  arc4_nstirs.add(1);
  abi::safe_memzero(buf.data(), buf.size());
}

bool rs_initialized = false;

auto _rs_stir_if_needed(size_t len) noexcept -> void {
  if (!rs_initialized) {
    _rs_init(rs_buf.data(), KEYSZ + IVSZ);
    rs_count = 1024 * 1024 * 1024;  // until main() runs */
    rs_initialized = true;
  } else if (rs_count <= len) {
    _rs_stir(0);
  } else {
    rs_count -= len;
  }
}

auto _rs_random_buf(void* bufptr, size_t n) noexcept -> void {
  uint8_t* buf = static_cast<uint8_t*>(bufptr);
  _rs_stir_if_needed(n);
  while (n > 0) {
    if (rs_have > 0) {
      size_t m = min(n, rs_have);
      copy_n(rs_buf.end() - rs_have, m, buf);
      fill_n(rs_buf.end() - rs_have, m, 0);
      buf += m;
      n -= m;
      rs_have -= m;
    }
    if (rs_have == 0) _rs_rekey(nullptr, 0);
  }
}

auto _rs_random_u32(uint32_t* val) noexcept -> void {
  _rs_stir_if_needed(sizeof(*val));
  if (rs_have < sizeof(*val)) _rs_rekey(nullptr, 0);
  copy_n(rs_buf.end() - rs_have, sizeof(*val),
              reinterpret_cast<uint8_t*>(val));
  fill_n(rs_buf.end() - rs_have, sizeof(*val), 0);
  rs_have -= 4;
}

auto arc4_init(void*, void*) noexcept -> void {
  _rs_stir(1);
}

/* Called by timeout to mark arc4 for stirring. */
auto arc4_reinit(void*) noexcept -> void {
#if 0
  static task arc4_task;
  static timeout arc4_timeout;

  task_add(systq, &arc4_task);
  /* 10 minutes, per dm@'s suggestion */
  timeout_add_sec(&arc4_timeout, chrono::minutes(10));
#endif
}


} /* namespace ilias::rnd::<unnamed> */


/*
 * Start periodic services inside the random subsystem, which pull
 * entropy forward, hash it, and re-seed the random stream as needed.
 */
auto random_start() noexcept -> void {
  const string_ref git_sha = "$Id$";

  /* Provide some data from this kernel. */
  add_entropy_string(git_sha);

  rs_initialized = true;
  dequeue_randomness();
  arc4_init(nullptr, nullptr);
#if 0
  task_set(&arc4_task, &arc4_init, nullptr, nullptr);
  timeout_set(&arc4_timeout, &arc4_reinit, nullptr);
#endif
  arc4_reinit(nullptr);
#if 0
  timeout_set(&rnd_timeout, &dequeue_randomness, nullptr);
#endif
}


entropy_source::rnd_src_stats::rnd_src_stats(string_ref name) noexcept
: grp_(stats_rnd_src_grp, name),
  calls(grp_, "calls"),
  bits(grp_, "bits")
{}


entropy_source::entropy_source(string_ref name, bool count_entropy,
                               bool max_entropy) noexcept
: count_entropy_(count_entropy),
  max_entropy_(max_entropy),
  stats_(name)
{}

entropy_source::~entropy_source() noexcept {}

/*
 * This function adds entropy to the entropy pool by using timing
 * delays.  It uses the entropy_source structure to make an estimate
 * of how many bits of entropy this call has added to the pool.
 *
 * The number "val" is also added to the pool - it should somehow describe
 * the type of event which just happened.  Currently the values of 0-255
 * are for keyboard scan codes, 256 and upwards - for interrupts.
 * On i386, this is assumed to be at most 16 bits, and the high bits
 * are used for a high-resolution timer.
 */
auto entropy_source::enqueue_randomness(int val) noexcept -> void {
  rand_event* rep;
  time_point time;
  array<duration, 3> delta;
  unsigned int nbits;

#if 0
  if (timeout_initialized(&rnd_timeout))
#endif
    time = clock_type::now();

  val += (reinterpret_cast<uintptr_t>(this) / alignof(entropy_source)) << 13;

  nbits = 0;

  /*
   * Calculate the number of bits of randomness that we probably
   * added.  We take into account the first and second order
   * deltas in order to make our estimate.
   */
  if (count_entropy_) {
    delta[0] = time - last_time_;
    delta[1] = delta[0] - last_delta_[0];
    delta[2] = delta[1] - last_delta_[1];

    for (auto& i : delta)
      if (i < duration::zero()) i = -i;
    delta[0] = *min_element(delta.begin(), delta.end());
    delta[2] = (delta[0] /= 2U);

    auto dcount = delta[0].count();
    nbits = numeric_limits<decltype(dcount)>::digits - clz(dcount);
  } else if (max_entropy_)
    nbits = numeric_limits<decltype(val)>::digits;

  /* given the multi-order delta logic above, this should never happen */
  if (_predict_false(nbits >= 32)) return;

  lock_guard<mutex> lck{ entropylock };

  if (count_entropy_) {
    /*
     * The logic is to drop low-entropy entries,
     * in hope for dequeueing to be more randomfull
     */
    if (rnd_qlen() > QEVSLOW && nbits < QEVSBITS) {
      rnd_drople.add(1);
      return;
    }
    last_time_ = time;
    copy_n(begin(delta), min(delta.size(), last_delta_.size()),
           begin(last_delta_));
  }

  rep = rnd_put();
  if (!rep) {
    rnd_drops.add(1);
    return;
  }

  rep->re_state = this;
  rep->re_nbits = nbits;
  rep->re_time = time;
  rep->re_val = val;

  rnd_enqs.add(1);
  rnd_ed.add(nbits, 1);
  stats_.calls.add(1);
  stats_.bits.add(nbits);

#if 0
  if (rnd_qlen() > QEVSLOW / 2 &&
      timeout_initialized(&rnd_timeout) &&
      !timeout_pending(&rnd_timeout))
    timeout_add(&rnd_timeout, 1);
#endif
}


auto get_timer_entropy_source() noexcept -> entropy_source& {
  static entropy_source timer_src{ "timer", false };
  return timer_src;
}

auto add_timer_randomness(int v) noexcept -> void {
  get_timer_entropy_source().enqueue_randomness(v);
}


}} /* namespace ilias::rnd */

/* These are declared by cstdlib. */
namespace std {


using namespace ilias::rnd;


/* Return one word of randomnes from an RC4 generator */
auto arc4random() noexcept -> uint32_t {
  uint32_t ret;

  {
    lock_guard<mutex> lck{ rndlock };
    _rs_random_u32(&ret);
  }
  arc4_reads.add(sizeof(ret));
  return ret;
}

/* Return two words of randomness from an RC4 generator */
auto arc4random64() noexcept -> uint64_t {
  uint32_t v0, v1;

  {
    lock_guard<mutex> lck{ rndlock };
    _rs_random_u32(&v0);
    _rs_random_u32(&v1);
  }
  arc4_reads.add(sizeof(v0) + sizeof(v1));
  return (static_cast<uint64_t>(v0) << 32) | static_cast<uint64_t>(v1);
}

/* Fill a buffer of arbitrary length with RC4-derived randomness. */
auto arc4random_buf(void* buf, size_t n) noexcept -> void {
  {
    lock_guard<mutex> lck{ rndlock };
    _rs_random_buf(buf, n);
  }
  arc4_reads.add(n);
}

/*
 * Calculate a uniformly distributed random number less than upper_bound
 * avoiding "modulo bias".
 *
 * Uniformity is achieved by generating new random numbers until the one
 * returned is outside the range [0, 2**32 % upper_bound).  This
 * guarantees the selected random number will be inside
 * [2**32 % upper_bound, 2**32) which maps back to [0, upper_bound)
 * after reduction modulo upper_bound.
 */
auto arc4random_uniform(uint32_t upper_bound) noexcept -> uint32_t {
  uint32_t r;

  if (upper_bound < 2) return 0;

  /* 2**32 % x == (2**32 - x) % x */
  const uint32_t min = -upper_bound % upper_bound;

  /*
   * This could theoretically loop forever but each retry has
   * p > 0.5 (worst case, usually far better) of selecting a
   * number inside the range we need, so it should rarely need
   * to re-roll.
   */
  do {
    r = arc4random();
  } while (r < min);

  return r % upper_bound;
}

auto arc4random_uniform64(uint64_t upper_bound) noexcept -> uint64_t {
  uint64_t r;

  if (upper_bound < 2) return 0;

  /* 2**64 % x == (2**64 - x) % x */
  const uint64_t min = -upper_bound % upper_bound;

  /*
   * This could theoretically loop forever but each retry has
   * p > 0.5 (worst case, usually far better) of selecting a
   * number inside the range we need, so it should rarely need
   * to re-roll.
   */
  do {
    r = arc4random64();
  } while (r < min);

  return r % upper_bound;
}


} /* namespace std */
